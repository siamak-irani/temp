حتماً Siamak عزیز! چون با ساختارهای سطح پایین مثل tokenizer آشنایی خوبی داری، اجازه بده کامل و مرحله‌به‌مرحله بگم که چطور می‌تونی با `marked` یک **توکنایزر سفارشی** بسازی، چرا کاربردیه، و چطور می‌تونی الگوهای خاص خودت رو به Markdown اضافه کنی.

---

### 🚀 چرا از Tokenizer سفارشی استفاده کنیم؟

وقتی می‌خوای یک الگوی خاص (مثل `[[badge: important]]` یا `{{highlighted text}}`) رو از دل متن Markdown جدا کنی و خروجی HTML اختصاصی براش بسازی، `renderer` کافی نیست. باید الگوی خاصت رو در مرحله‌ی تحلیل _توکن‌ها_ بشناسی. اینجاست که tokenizer وارد بازی می‌شه.

---

### 🧠 ساختار Tokenizer در `marked`

یک tokenizer سفارشی باید شامل موارد زیر باشه:

| ویژگی         | توضیح                                                                 |
|---------------|------------------------------------------------------------------------|
| `name`        | اسم توکن جدید (مثلاً `badgeTag`)                                      |
| `level`       | نوع توکن: `block` یا `inline`                                          |
| `start(src)`  | محل شروع بررسی متن؛ برای بهینه‌سازی و رد سریع قسمت‌هایی که نامرتبط‌اند |
| `tokenizer(src)` | بررسی کامل متن برای پیدا کردن توکن و برگردوندن آبجکت توکن        |

---

### 🧪 نمونه کامل توکنایزر برای الگوی `[[badge: value]]`

```js
import { marked } from 'marked';

const customTokenizer = {
  name: 'badgeTag',
  level: 'inline',
  start(src) {
    return src.match(/\[\[badge:/)?.index;
  },
  tokenizer(src) {
    const match = /^\[\[badge: (.+?)\]\]/.exec(src);
    if (match) {
      return {
        type: 'badgeTag',
        raw: match[0],
        text: match[1],
        tokens: [] // در صورت نیاز به پردازش داخلی
      };
    }
  }
};

const customRenderer = {
  badgeTag(token) {
    return `<span class="badge">${token.text}</span>`;
  }
};

marked.use({ tokenizer: customTokenizer, renderer: customRenderer });

const md = `
متن تستی [[badge: مهم]] در وسط پاراگراف.
`;

console.log(marked.parse(md));
```

---

### 💡 نکات پیشرفته

- اگر الگوی توی توکن خودش شامل Markdown باشه، از `tokens: marked.lexer(token.text)` استفاده کن تا توکن‌های داخلی پردازش بشن.
- می‌تونی چند tokenizer همزمان اضافه کنی. هر کدوم باید اسم متفاوت داشته باشن.
- می‌تونی `block-level tokenizer` هم بنویسی. مثلاً برای الگوهای چندخطی مثل:

```
:::alert
متن هشدار!
:::
```

---

### 🤯 ترکیب با CSS و تعامل با Frontend

حالا که توکن رو شناختی و HTML رو ساختی، فقط کافیه با کلاس‌هایی مثل `.badge`, `.alert-box`, `.tagged-text` در CSS ظاهر دلخواهت رو بسازی. مثلاً:

```css
.badge {
  background-color: #f00;
  color: white;
  padding: 2px 6px;
  border-radius: 4px;
  font-weight: bold;
}
```

---

اگر الگوی خاصی تو ذهنت هست، مثل الگوهای مالی یا دیتا محور، می‌تونیم با هم تبدیلش کنیم به یک parser کامل. دوست داری یکی از الگوهایی که برای نمایش دیتا استفاده می‌کنی رو مارک‌داون‌پسند کنیم؟ 😄


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

خیلی سؤال خوبی پرسیدی Siamak! بیا با هم دقیق بررسی کنیم که `tokens: marked.lexer(token.text)` یعنی چی و چه‌وقتی مفیده.

---

### 🔍 اول: توکن داخل توکن یعنی چی؟

فرض کن یه الگوی سفارشی داری مثل `[[note: **خیلی مهم**]]`. داخلش Markdown هست (`**خیلی مهم**` یعنی bold). حالا تو tokenizer سفارشی‌مون وقتی `text` رو می‌گیریم، اون فقط یک رشته خامه.

ولی اگر بخوای اون `text` رو هم به صورت Markdown پردازش کنی (مثلاً bold، italic یا لینک‌ها)، باید جداگانه روش Markdown parser اجرا بشه.

---

### 💡 راه‌حل: استفاده از `marked.lexer(token.text)`

با `marked.lexer(token.text)` اون بخش از متن رو تبدیل می‌کنی به آرایه‌ای از **توکن‌های داخلی** Markdown که می‌تونن دوباره توسط `marked.parser()` تبدیل به HTML بشن.

### 📦 نمونه کاربردی

```js
const tokenizer = {
  name: 'noteTag',
  level: 'inline',
  start(src) {
    return src.match(/\[\[note:/)?.index;
  },
  tokenizer(src) {
    const match = /^\[\[note: (.*?)\]\]/.exec(src);
    if (match) {
      return {
        type: 'noteTag',
        raw: match[0],
        text: match[1],
        tokens: marked.lexer(match[1]) // 👈 پردازش داخلی Markdown
      };
    }
  }
};

const renderer = {
  noteTag(token) {
    return `<div class="note">${marked.parser(token.tokens)}</div>`;
  }
};
```

### ✅ خروجی نهایی

```
[[note: **خیلی مهم**]]
```

به HTML تبدیل می‌شه:

```html
<div class="note"><p><strong>خیلی مهم</strong></p></div>
```

---

### ✨ خلاصه کاربردها

- اگر درون الگوی شخصی‌ات از Markdown استفاده می‌کنی، `marked.lexer(token.text)` بهت اجازه می‌ده اون قسمت رو هم با قوانین Markdown پردازش کنی.
- در نتیجه خروجی نهایی هم می‌تونه شامل bold، italic، لینک، یا حتی لیست باشه.

اگه یه الگوی واقعی در ذهن داری که داخلش Markdown باشه، بی‌صبرانه منتظرم تا با هم پیاده‌سازیش کنیم 😊 دوست داری یه مثال واقعی خودت رو با Markdown داخلی بسازیم؟












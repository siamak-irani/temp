در این پیاده‌سازی از دو مکانیسم استفاده می‌کنیم:

1. **Web Locks API** (برای مرورگرهایی که پشتیبانی می‌کنند)
2. **Fallback با LocalStorage + Promise** (برای مرورگرهای قدیمی یا زمانی که Web Locks غیرفعال است)

ایده کلی:

* قبل از هر درخواست اصلی، تابع `getValidToken()` را صدا می‌زنیم.
* این تابع اولاً بررسی می‌کند که توکن فعلی تا وقتی Timeout نشده.
* اگر نیاز به رفرش بود:

  * اگر Web Locks در دسترس باشد، با `navigator.locks.request("token-refresh", …)` وارد Critical Section می‌شویم، دوباره چک می‌کنیم و یک‌بار رفرش می‌کنیم.
  * در غیر این صورت با استفاده از LocalStorage یک قفل «ساده» می‌سازیم:

    * اولین تب/درخواست برچسب `refreshing` را می‌گذارد و رفرش می‌کند.
    * بقیه با شنیدن رویداد `storage` روی کلید توکن، تا زمان آپدیت منتظر می‌مانند.

```js
// ---- Helpers ----

// وقتی LocalStorage روی کلید خاصی تغییر کرد این پرامیس Resolve می‌شود
function waitForLocalStorageChange(keyToWatch) {
  return new Promise(resolve => {
    function handler(event) {
      if (event.key === keyToWatch) {
        window.removeEventListener("storage", handler);
        resolve(event.newValue);
      }
    }
    window.addEventListener("storage", handler);
  });
}

// تابع واقعی که درخواست رفرش می‌زند و پاسخ { token, expiry } برمی‌گرداند
async function fetchNewToken() {
  const resp = await fetch("/auth/refresh", {
    method: "POST",
    credentials: "include"
  });
  if (!resp.ok) throw new Error("Refresh failed");
  return resp.json(); // { token: "...", expiry: 1690000000000 }
}

// ---- Core Function ----

/**
 * همیشه از این تابع برای گرفتن توکن استفاده کن.
 * خودش در صورت نیاز، توکن را فقط یکبار رفرش می‌کند.
 */
async function getValidToken() {
  const THRESHOLD = 10 * 1000;  // ۱۰ ثانیه قبل از expiry
  const now = Date.now();
  let token = localStorage.getItem("token");
  let expiry = parseInt(localStorage.getItem("tokenExpiry") || "0", 10);

  // اگر هنوز توکن معتبر است، بدون هیچ‌کاری برگردان
  if (token && now < expiry - THRESHOLD) {
    return token;
  }

  // اگر Web Locks API موجود است، از آن استفاده کن
  if ("locks" in navigator) {
    return navigator.locks.request("token-refresh", async () => {
      // داخل lock دوباره چک کن (ممکن است تَب دیگری قبلاً رفرش کرده باشد)
      token = localStorage.getItem("token");
      expiry = parseInt(localStorage.getItem("tokenExpiry") || "0", 10);
      if (token && Date.now() < expiry - THRESHOLD) {
        return token;
      }
      // حالا واقعاً رفرش می‌کنیم
      const { token: newToken, expiry: newExpiry } = await fetchNewToken();
      localStorage.setItem("token", newToken);
      localStorage.setItem("tokenExpiry", newExpiry.toString());
      return newToken;
    });
  }

  // Fallback: شبیه قفل ساده با localStorage
  const isRefreshing = localStorage.getItem("refreshing") === "1";

  if (isRefreshing) {
    // اگر کسی قبلاً شروع کرده، منتظر تغییر توکن بمان
    await waitForLocalStorageChange("token");
    return localStorage.getItem("token");
  } else {
    // اولین خواستار اینجا می‌آید
    try {
      localStorage.setItem("refreshing", "1");
      const { token: newToken, expiry: newExpiry } = await fetchNewToken();
      localStorage.setItem("token", newToken);
      localStorage.setItem("tokenExpiry", newExpiry.toString());
      // این تریگر باعث می‌شود تب‌های دیگر از waitForLocalStorageChange بیرون بیایند
      localStorage.setItem("token", newToken);
      return newToken;
    } finally {
      localStorage.removeItem("refreshing");
    }
  }
}

// ---- Usage Example ----

async function apiRequest(url, options = {}) {
  const token = await getValidToken();
  options.headers = {
    ...(options.headers || {}),
    Authorization: `Bearer ${token}`
  };
  return fetch(url, options);
}

// مثال:
// apiRequest("/data").then(r => r.json()).then(console.log);
```

---

### نکات

* **THRESHOLD** به شما اجازه می‌دهد کمی زودتر رفرش کنید تا وقفه‌ی درخواست نداشته باشید.
* LocalStorage event بین **تب‌های مختلف** فراخوانی می‌شود؛ برای **درخواست‌های هم‌زمان در یک تب** Web Locks API یا همان پرامیس داخلی JavaScript کفایت می‌کند.
* می‌توانید `navigator.locks.request` را با گزینه `{mode: "exclusive"}` هم صریح کنید، ولی حالت پیش‌فرض برای یک نام lock واحد همین Exclusive است.

این ساختار اطمینان می‌دهد که در هر زمان فقط **یک** رفرش انجام شود و همه‌ی درخواست‌های دیگر تا پایان آن صبر کنند.


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

در این نسخه هر دو مکانیزم به‌صورت ترکیبی و هم‌زمان بررسی می‌شوند:

1. اگر **Web Locks API** در دسترس باشد، ابتدا با `navigator.locks.request` وارد Critical Section می‌شویم.
2. داخل قفل، علاوه بر رفرش با Web Locks، وضعیت LocalStorage (پرچم `refreshing`) را هم می‌سنجیم تا در صورت باز بودن چند تب، حتی وقتی Web Lock یکسان در تب‌ها اجرا شود، از رفرش تکراری جلوگیری کنیم.
3. اگر Web Locks در دسترس نباشد، فقط از پرچم LocalStorage برای قفل‌گذاری بین تب‌ها استفاده می‌کنیم.

```js
// ---------- Helpers ----------

// صبر می‌کنیم تا localStorage روی کلید key تغییر کند
function waitForLocalStorageChange(key) {
  return new Promise(resolve => {
    function handler(e) {
      if (e.key === key) {
        window.removeEventListener('storage', handler);
        resolve(e.newValue);
      }
    }
    window.addEventListener('storage', handler);
  });
}

// درخواست رفرش توکن
async function fetchNewToken() {
  const resp = await fetch('/auth/refresh', {
    method: 'POST',
    credentials: 'include'
  });
  if (!resp.ok) throw new Error('Refresh failed');
  return resp.json(); // { token, expiry }
}

// ---------- Core Function ----------

async function getValidToken() {
  const THRESHOLD = 10_000;  // ۱۰ ثانیه
  const now = Date.now();
  let token = localStorage.getItem('token');
  let expiry = parseInt(localStorage.getItem('tokenExpiry') || '0', 10);

  // اگر فعلاً معتبر است
  if (token && now < expiry - THRESHOLD) {
    return token;
  }

  // یک پرامیس مرکزی برای عملیات رفرش
  const doRefresh = async () => {
    // دوباره چک می‌کنیم—ممکن است تب دیگر انجام داده باشد
    token = localStorage.getItem('token');
    expiry = parseInt(localStorage.getItem('tokenExpiry') || '0', 10);
    if (token && Date.now() < expiry - THRESHOLD) {
      return token;
    }

    // اگر هنوز نیاز هست:
    localStorage.setItem('refreshing', '1');
    try {
      const { token: newToken, expiry: newExpiry } = await fetchNewToken();
      localStorage.setItem('token', newToken);
      localStorage.setItem('tokenExpiry', newExpiry.toString());
      // یک بار دیگر ست می‌کنیم تا تب‌های منتظر بیدار شوند
      localStorage.setItem('token', newToken);
      return newToken;
    } finally {
      localStorage.removeItem('refreshing');
    }
  };

  // اول: Web Locks API (اگر موجود باشد)
  if ('locks' in navigator) {
    return navigator.locks.request('token-refresh', async () => {
      // ترکیب با LocalStorage داخل قفل
      const isRefreshing = localStorage.getItem('refreshing') === '1';
      if (isRefreshing) {
        await waitForLocalStorageChange('token');
        return localStorage.getItem('token');
      }
      return doRefresh();
    });
  }

  // اگر Web Locks موجود نیست: فقط LocalStorage
  const isRefreshing = localStorage.getItem('refreshing') === '1';
  if (isRefreshing) {
    await waitForLocalStorageChange('token');
    return localStorage.getItem('token');
  }
  return doRefresh();
}

// ---------- Usage Example ----------

async function apiRequest(url, options = {}) {
  const token = await getValidToken();
  options.headers = {
    ...(options.headers || {}),
    Authorization: `Bearer ${token}`
  };
  return fetch(url, options);
}

// مثال:
// apiRequest('/data').then(r => r.json()).then(console.log);
```

**نکات مهم**

* پرچم `refreshing` در LocalStorage بین تب‌ها هماهنگی می‌کند.
* Web Locks API روی یک نام قفل (`token-refresh`) از تداخل چند تابع در یک تب (یا حتی چند تب) جلوگیری می‌کند.
* درون قفل مجدداً وضعیت `refreshing` و زمان انقضا چک می‌شود تا اگر تب دیگری قبلاً رفرش کرده بود، رفرش دوباره انجام نشود.
* برای مرورگرهایی که Web Locks ندارند، فقط مکانیزم LocalStorage فعال است.

import {
    closestCorners,
    DndContext,
    DragOverlay,
    KeyboardSensor,
    PointerSensor,
    useSensor,
    useSensors,
} from '@dnd-kit/core'
import { arrayMove, sortableKeyboardCoordinates } from '@dnd-kit/sortable'
import { createContext, useCallback, useEffect, useState } from 'react'
import PropTypes from 'prop-types'
import {
    cards,
    columns,
    saleKanbanCards,
    saleKanbanColumns,
} from './new-kanban-data'
import { Column } from './components'

export const KanbanContext = createContext()

function NewKanban({ CardComponent, fetchCards, fetchColumns }) {
    const initialState = columns.map((c, index) => ({
        ...c,
        cards: cards[index].items,
    }))

    const [state, setState] = useState([])
    const [isDragging, setIsDragging] = useState(false)
    const [activeId, setActiveId] = useState(null)

    const getColumns = useCallback(async () => {
        const columns = await fetchColumns()
        setState(columns)
    }, [])

    useEffect(() => {
        setState([])
        getColumns()
    }, [])

    // useEffect(() => {
    //     console.log(state)
    // }, [state])

    const findColumn = (unique) => {
        if (!unique) {
            return null
        }
        if (state.some((c) => c.id === unique)) {
            return state.find((c) => c.id === unique) ?? null
        }
        const id = String(unique)
        const itemWithColumnId = state.flatMap((c) => {
            const columnId = c.id
            return c.cards.map((i) => ({ itemId: i.id, columnId: columnId }))
        })
        const columnId = itemWithColumnId.find((i) => i.itemId === id)?.columnId
        return state.find((c) => c.id === columnId) ?? null
    }

    const handleDragStart = (event) => {
        setIsDragging(true)
        setActiveId(event.active.id)
    }

    const handleDragOver = (event) => {
        const { active, over, delta } = event
        const activeId = String(active.id)
        const overId = over ? String(over.id) : null
        const activeColumn = findColumn(activeId)
        const overColumn = findColumn(overId)
        if (!activeColumn || !overColumn || activeColumn === overColumn) {
            return null
        }
        setState((prevState) => {
            const activeItems = activeColumn.cards
            const overItems = overColumn.cards
            const activeIndex = activeItems.findIndex((i) => i.id === activeId)
            const overIndex = overItems.findIndex((i) => i.id === overId)

            const newIndex = () => {
                const putOnBelowLastItem =
                    overIndex === overItems.length - 1 && delta.y > 0
                const modifier = putOnBelowLastItem ? 1 : 0
                return overIndex >= 0
                    ? overIndex + modifier
                    : overItems.length + 1
            }
            return prevState.map((c) => {
                if (c.id === activeColumn.id) {
                    c.cards = activeItems.filter((i) => i.id !== activeId)
                    return c
                } else if (c.id === overColumn.id) {
                    c.cards = [
                        ...overItems.slice(0, newIndex()),
                        activeItems[activeIndex],
                        ...overItems.slice(newIndex(), overItems.length),
                    ]
                    return c
                } else {
                    return c
                }
            })
        })
    }

    const handleDragEnd = (event) => {
        setIsDragging(false)
        setActiveId(null)

        const { active, over } = event
        const activeId = String(active.id)
        const overId = over ? String(over.id) : null
        const activeColumn = findColumn(activeId)
        const overColumn = findColumn(overId)
        if (!activeColumn || !overColumn || activeColumn !== overColumn) {
            return null
        }
        const activeIndex = activeColumn.cards.findIndex(
            (i) => i.id === activeId
        )
        const overIndex = overColumn.cards.findIndex((i) => i.id === overId)

        if (activeIndex !== overIndex) {
            setState((prevState) => {
                return prevState.map((column) => {
                    if (column.id === activeColumn.id) {
                        column.cards = arrayMove(
                            overColumn.cards,
                            activeIndex,
                            overIndex
                        )
                        return column
                    } else {
                        return column
                    }
                })
            })
        }
    }

    const sensors = useSensors(
        useSensor(PointerSensor),
        useSensor(KeyboardSensor, {
            coordinateGetter: sortableKeyboardCoordinates,
        })
    )

    return (
        <KanbanContext.Provider
            value={{ state, setState, CardComponent, isDragging, activeId }}
        >
            <DndContext
                sensors={sensors}
                collisionDetection={closestCorners}
                onDragStart={handleDragStart}
                onDragOver={handleDragOver}
                onDragEnd={handleDragEnd}
            >
                <DragOverlay>
                    {activeId ? (
                        <div style={{ padding: 10, background: 'lightgray' }}>
                            {activeId}
                        </div>
                    ) : null}
                </DragOverlay>
                <div
                    style={{
                        display: 'flex',
                        flexDirection: 'row',
                        padding: '20px',
                    }}
                >
                    {state.length !== 0 ? (
                        state.map((column) => (
                            <Column
                                c={column}
                                key={column.id}
                                id={column.id}
                                title={column.title}
                                cards={column.cards}
                                fetchCards={fetchCards}
                            />
                        ))
                    ) : (
                        <div>loading...</div>
                    )}
                </div>
            </DndContext>
        </KanbanContext.Provider>
    )
}

NewKanban.propTypes = {
    columns: PropTypes.array,
    cards: PropTypes.array,
    data: PropTypes.array,
    CardComponent: PropTypes.func,
}

export default function NewKanbanBoard() {
    const Card = () => {
        return <div>Hello world</div>
    }

    const fetchColumns = useCallback(async () => {
        await new Promise((resolve) => setTimeout(resolve, 500))
        return saleKanbanColumns.steps
    }, [])

    const fetchCards = useCallback(async (columnId, page) => {
        await new Promise((resolve) => setTimeout(resolve, 500))
        return saleKanbanCards[columnId -1]
    }, [])

    return (
        <NewKanban
            CardComponent={Card}
            fetchColumns={fetchColumns}
            fetchCards={fetchCards}
        />
    )
}

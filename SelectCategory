Ø¨Ø§Ø´Ù‡ ðŸ‘Œ Ù…Ù† Ø¯Ùˆ Ù†Ø³Ø®Ù‡ Ø§Ø² `onDrop` Ø¨Ø±Ø§Øª Ù…ÛŒâ€ŒÙ†ÙˆÛŒØ³Ù…:

---

## ðŸ”¹ Ù†Ø³Ø®Ù‡ Û±: Ù…Ù†Ø·Ù‚ Ù‚Ø¯ÛŒÙ…ÛŒ (Ø¨Ø§Ø²Ù†ÙˆÛŒØ³ÛŒ Ú©Ù„ displayOrder)

Ø§ÛŒÙ† Ù‡Ù…ÙˆÙ† Ú†ÛŒØ²ÛŒÙ‡ Ú©Ù‡ ØªÙˆ Ø¯Ø§Ø´ØªÛŒ â†’ Ú©Ù„ Ø¨Ú†Ù‡â€ŒÙ‡Ø§ÛŒ parent Ø¯ÙˆØ¨Ø§Ø±Ù‡ `displayOrder` Ù…ÛŒâ€ŒÚ¯ÛŒØ±Ù†.

```js
const onDrop = useCallback(
    (info) => {
        const dropKey = info.node.key
        const dragKey = info.dragNode.key
        const dropPos = info.node.pos.split('-')
        const dropPosition =
            info.dropPosition - Number(dropPos[dropPos.length - 1])

        const loop = (data, key, callback) => {
            for (let i = 0; i < data.length; i++) {
                if (data[i].key === key) {
                    return callback(data[i], i, data)
                }
                if (data[i].children) {
                    loop(data[i].children, key, callback)
                }
            }
        }

        const dataCopy = [...gData]
        let dragObj

        loop(dataCopy, dragKey, (item, index, arr) => {
            arr.splice(index, 1)
            dragObj = item
        })

        let updatedParentChildren = []
        let parentKey = null

        if (!info.dropToGap) {
            loop(dataCopy, dropKey, (item) => {
                item.children = item.children || []
                item.children.unshift(dragObj)
                updatedParentChildren = item.children
                parentKey = item.key
            })
        } else {
            let ar = []
            let i
            loop(dataCopy, dropKey, (_item, index, arr) => {
                ar = arr
                i = index
            })
            if (dropPosition === -1) {
                ar.splice(i, 0, dragObj)
            } else {
                ar.splice(i + 1, 0, dragObj)
            }

            const findParentKey = (data, childKey) => {
                let result = null
                const search = (nodes, parent = null) => {
                    for (const node of nodes) {
                        if (node.key === childKey) {
                            result = parent
                            return
                        }
                        if (node.children) {
                            search(node.children, node.key)
                        }
                    }
                }
                search(data)
                return result
            }

            parentKey = findParentKey(dataCopy, dragObj.key)

            const getChildren = (data, key) => {
                let children = []
                loop(data, key, (item) => {
                    children = item.children || []
                })
                return children
            }

            updatedParentChildren = parentKey
                ? getChildren(dataCopy, parentKey)
                : dataCopy
        }

        if (dragObj) {
            dragObj.parentId =
                parentKey !== null ? parseInt(parentKey, 10) : null
        }

        const prevOrderMap = new Map()
        updatedParentChildren.forEach((item) => {
            if (item) {
                prevOrderMap.set(item.key, item.displayOrder ?? 0)
            }
        })

        const sortedOrder = updatedParentChildren
            .map((item) => item?.displayOrder ?? 0)
            .sort((a, b) => b - a)

        const changedItems = []
        updatedParentChildren.forEach((item, index) => {
            if (item) {
                const oldOrder = prevOrderMap.get(item.key)
                item.displayOrder = sortedOrder[index]
                if (item.displayOrder !== oldOrder) {
                    changedItems.push({
                        ...item,
                    })
                }
            }
        })

        if (dragObj) {
            changedItems.push({
                ...dragObj,
            })
        }

        setGData(dataCopy)
        onItemChange?.(changedItems)
    },
    [gData, onItemChange, setGData]
)
```

---

## ðŸ”¹ Ù†Ø³Ø®Ù‡ Û²: Ù…Ù†Ø·Ù‚ Ø¬Ø¯ÛŒØ¯ (ÙÙ‚Ø· swap Ú©Ø±Ø¯Ù† displayOrder)

Ø§ÛŒÙ†Ø¬Ø§ ÙÙ‚Ø· Ø¯Ùˆ Ø¢ÛŒØªÙ…ÛŒ Ú©Ù‡ Ø¬Ø§Ø¨Ù‡â€ŒØ¬Ø§ Ù…ÛŒØ´Ù† `displayOrder`Ø´ÙˆÙ† Ø¨Ø§ Ù‡Ù… ØªØ¹ÙˆÛŒØ¶ Ù…ÛŒØ´Ù‡.

```js
const onDrop = useCallback(
    (info) => {
        const dropKey = info.node.key
        const dragKey = info.dragNode.key
        const dropPos = info.node.pos.split('-')
        const dropPosition =
            info.dropPosition - Number(dropPos[dropPos.length - 1])

        const loop = (data, key, callback) => {
            for (let i = 0; i < data.length; i++) {
                if (data[i].key === key) {
                    return callback(data[i], i, data)
                }
                if (data[i].children) {
                    loop(data[i].children, key, callback)
                }
            }
        }

        const dataCopy = [...gData]
        let dragObj

        loop(dataCopy, dragKey, (item, index, arr) => {
            arr.splice(index, 1)
            dragObj = item
        })

        let updatedParentChildren = []
        let parentKey = null

        if (!info.dropToGap) {
            loop(dataCopy, dropKey, (item) => {
                item.children = item.children || []
                item.children.unshift(dragObj)
                updatedParentChildren = item.children
                parentKey = item.key
            })
        } else {
            let ar = []
            let i
            loop(dataCopy, dropKey, (_item, index, arr) => {
                ar = arr
                i = index
            })
            if (dropPosition === -1) {
                ar.splice(i, 0, dragObj)
            } else {
                ar.splice(i + 1, 0, dragObj)
            }

            const findParentKey = (data, childKey) => {
                let result = null
                const search = (nodes, parent = null) => {
                    for (const node of nodes) {
                        if (node.key === childKey) {
                            result = parent
                            return
                        }
                        if (node.children) {
                            search(node.children, node.key)
                        }
                    }
                }
                search(data)
                return result
            }

            parentKey = findParentKey(dataCopy, dragObj.key)

            const getChildren = (data, key) => {
                let children = []
                loop(data, key, (item) => {
                    children = item.children || []
                })
                return children
            }

            updatedParentChildren = parentKey
                ? getChildren(dataCopy, parentKey)
                : dataCopy
        }

        if (dragObj) {
            dragObj.parentId =
                parentKey !== null ? parseInt(parentKey, 10) : null
        }

        const changedItems = []

        // Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯Ù† Ø¢ÛŒØªÙ…ÛŒ Ú©Ù‡ Ø¨Ø§ dragObj Ø¬Ø§Ø¨Ù‡â€ŒØ¬Ø§ Ø´Ø¯Ù‡
        const oldIndex = updatedParentChildren.findIndex(
            (item) => item.key === dragObj.key
        )
        const newIndex = updatedParentChildren.indexOf(dragObj)

        if (
            oldIndex !== -1 &&
            newIndex !== -1 &&
            oldIndex !== newIndex
        ) {
            const oldItem = updatedParentChildren[oldIndex]
            const newItem = updatedParentChildren[newIndex]

            // swap Ú©Ø±Ø¯Ù† displayOrder
            const tempOrder = oldItem.displayOrder
            oldItem.displayOrder = newItem.displayOrder
            newItem.displayOrder = tempOrder

            changedItems.push({ ...oldItem })
            changedItems.push({ ...newItem })
        }

        setGData(dataCopy)
        onItemChange?.(changedItems)
    },
    [gData, onItemChange, setGData]
)
```

---

âš–ï¸ Ø­Ø§Ù„Ø§ ØªÙˆ Ù…ÛŒâ€ŒØªÙˆÙ†ÛŒ ØªØµÙ…ÛŒÙ… Ø¨Ú¯ÛŒØ±ÛŒ:

* Ø§Ú¯Ù‡ Ø³Ø±ÙˆØ± Ø§Ù†ØªØ¸Ø§Ø± Ø¯Ø§Ø±Ù‡ **Ú©Ù„ ØªØ±ØªÛŒØ¨ Ø¨Ø§Ø²Ù†ÙˆÛŒØ³ÛŒ Ø¨Ø´Ù‡** â†’ Ù†Ø³Ø®Ù‡ Û±.
* Ø§Ú¯Ù‡ ÙÙ‚Ø· **swap Ø¨ÛŒÙ† Ø¯Ùˆ Ø¢ÛŒØªÙ… Ù…ØªÙˆØ§Ù„ÛŒ** Ù„Ø§Ø²Ù…Ù‡ â†’ Ù†Ø³Ø®Ù‡ Û².

Ù…ÛŒâ€ŒØ®ÙˆØ§ÛŒ Ù…Ù† Ù†Ø³Ø®Ù‡ Û² Ø±Ùˆ Ø·ÙˆØ±ÛŒ Ú¯Ø³ØªØ±Ø´ Ø¨Ø¯Ù… Ú©Ù‡ ÙˆÙ‚ØªÛŒ Ø¢ÛŒØªÙ… Ø¨ÛŒÙ† Ø¯Ùˆ parent Ù…Ø®ØªÙ„Ù Ø¬Ø§Ø¨Ù‡â€ŒØ¬Ø§ Ù…ÛŒØ´Ù‡ Ù‡Ù… Ù…Ù‚Ø¯Ø§Ø± `displayOrder` Ø¯Ø±Ø³Øª Ø³Øª Ø¨Ø´Ù‡ (Ù…Ø«Ù„Ø§Ù‹ Ø¨ÛŒÙ† Ù…Ù‚Ø§Ø¯ÛŒØ± Ù‡Ù…Ø³Ø§ÛŒÙ‡â€ŒÙ‡Ø§ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¨Ø´Ù‡)ØŸ

//////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////

Ø®ÛŒÙ„ÛŒ Ø¯Ù‚ÛŒÙ‚ Ù†Ú¯Ø§Ù‡ Ú©Ø±Ø¯Ù…. ðŸ‘‡

### Ù…Ø´Ú©Ù„ Ø§ØµÙ„ÛŒ (ØªÚ©Ø±Ø§Ø± ÙˆØ§Ù„Ø¯ ÙˆÙ‚ØªÛŒ Ú¯Ø±Ù‡ Ø±Ùˆ Ø¨ÛŒØ±ÙˆÙ† Ù…ÛŒâ€ŒÚ©Ø´ÛŒÙ…)

Ø¯Ù„ÛŒÙ„ Ø§ÛŒÙ†â€ŒÚ©Ù‡ ÙˆÙ‚ØªÛŒ ÛŒÚ© Ù†ÙˆØ¯ Ø±Ùˆ Ù…ÛŒâ€ŒÚ©Ø´ÛŒ Ø¯Ø§Ø®Ù„ ÛŒÚ© Ù†ÙˆØ¯ Ø¯ÛŒÚ¯Ù‡ (Ø¨Ù‡â€ŒØ¹Ù†ÙˆØ§Ù† ÙØ±Ø²Ù†Ø¯) Ùˆ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø¨ÛŒØ±ÙˆÙ† Ù…ÛŒâ€ŒÚ©Ø´ÛŒ Ø§Ø²Ø´ ÛŒÚ© **Ú©Ù¾ÛŒ Ø§Ø² ÙˆØ§Ù„Ø¯ Ø§ÛŒØ¬Ø§Ø¯ Ù…ÛŒØ´Ù‡**ØŒ Ø§ÛŒÙ† Ø¨Ø®Ø´Ù‡:

```js
if (!info.dropToGap) {
    loop(data, dropKey, (item) => {
        item.children = item.children || []
        item.children.unshift(dragObj)
        updatedParentChildren = item.children
        parentKey = item.key
    })
}
```

Ø§ÛŒÙ†Ø¬Ø§:

* ÙˆÙ‚ØªÛŒ ÛŒÚ© Ú¯Ø±Ù‡ Ù…ÛŒØ±Ù‡ Ø¯Ø§Ø®Ù„ ÛŒÚ© Ù†ÙˆØ¯ Ø¯ÛŒÚ¯Ù‡ØŒ Ø§ÙˆÙ† Ù†ÙˆØ¯ Ø¨Ù‡â€ŒØ²ÙˆØ± `children = item.children || []` Ù…ÛŒâ€ŒÚ¯ÛŒØ±Ù‡.
* Ø¨Ø¹Ø¯ `dragObj` Ø¨Ø§ `unshift` Ù…ÛŒØ±Ù‡ Ø¯Ø§Ø®Ù„Ø´.
* Ø§Ù…Ø§ ÙˆÙ‚ØªÛŒ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø¨ÛŒØ±ÙˆÙ† Ù…ÛŒâ€ŒÚ©Ø´ÛŒØ´ØŒ Ú†ÙˆÙ† `children` Ø¨Ø±Ø§ÛŒ Ø§ÙˆÙ† Ù†ÙˆØ¯ **Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯Ù‡ Ùˆ Ø®Ø§Ù„ÛŒ Ù†Ù…ÛŒâ€ŒØ´Ù‡**ØŒ Ù‡Ù…Ú†Ù†Ø§Ù† ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ù‡.
* Ùˆ Ø¨Ø¹Ø¯ ØªÙˆÛŒ ØªØ§Ø¨Ø¹ `findParentKey` ÙˆÙ‚ØªÛŒ Ø¯Ù†Ø¨Ø§Ù„ parent Ù…ÛŒâ€ŒÚ¯Ø±Ø¯ÛŒØŒ Ø¨Ø¹Ø¶ÛŒ ÙˆÙ‚Øªâ€ŒÙ‡Ø§ Ù†ÙˆØ¯ Ø®ÙˆØ¯Ø´ Ù‡Ù… Ø¨Ù‡â€ŒØ¹Ù†ÙˆØ§Ù† parent Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ù…ÛŒØ´Ù‡ (Ø¨Ù‡ Ø®Ø§Ø·Ø± children Ø§Ø¶Ø§ÙÙ‡â€ŒØ´Ø¯Ù‡).

ÛŒØ¹Ù†ÛŒ Ø¹Ù…Ù„Ø§Ù‹ ÛŒÚ© Ø³Ø§Ø®ØªØ§Ø± Ø¯Ø±Ø®ØªÛŒ Ù†Ø§Ø®ÙˆØ§Ø³ØªÙ‡ Ø¯Ø±Ø³Øª Ù…ÛŒØ´Ù‡ Ú©Ù‡ ØªÙˆØ´ **Ø®ÙˆØ¯ Ú¯Ø±Ù‡ ÛŒØ§ ÙˆØ§Ù„Ø¯Ø´ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ú©Ù¾ÛŒ Ù…ÛŒØ´Ù‡**.

### Ù…Ø´Ú©Ù„Ø§Øª Ø¯ÛŒÚ¯Ù‡â€ŒØ§ÛŒ Ú©Ù‡ Ø¯ÛŒØ¯Ù…

1. **Ø¹Ø¯Ù… ØªÙˆÙ‚Ù Ø¯Ø± `loop`:**
   Ø¯Ø± `loop` ÙˆÙ‚ØªÛŒ Ù†ÙˆØ¯ Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ù¾ÛŒØ¯Ø§ Ø´Ø¯ Ùˆ `callback` ØµØ¯Ø§ Ø²Ø¯Ù‡ Ø´Ø¯ØŒ Ù‡ÛŒÚ† `return` Ú©Ù„ÛŒ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ù‡. Ø§ÛŒÙ† Ø¨Ø§Ø¹Ø« Ù…ÛŒØ´Ù‡ Ø¬Ø³ØªØ¬Ùˆ Ø§Ø¯Ø§Ù…Ù‡ Ø¨Ø¯Ù‡ Ùˆ Ù…Ù…Ú©Ù†Ù‡ Ú†Ù†Ø¯ Ø¨Ø§Ø± `dragObj` Ø¬Ø§Ø¨Ù‡â€ŒØ¬Ø§ Ø¨Ø´Ù‡ ÛŒØ§ parent Ø§Ø´ØªØ¨Ø§Ù‡ Ù¾ÛŒØ¯Ø§ Ø¨Ø´Ù‡.

   Ø±Ø§Ù‡â€ŒØ­Ù„: Ø¨Ø¹Ø¯ Ø§Ø² Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯Ù† Ùˆ Ø§Ø¬Ø±Ø§ÛŒ `callback` Ø¨Ø§ÛŒØ¯ `return true` Ø¨Ø²Ù†ÛŒ Ùˆ ØªÙˆÛŒ Ù„Ø§ÛŒÙ‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ù„Ø§ØªØ± Ù‡Ù… Ø§Ú¯Ù‡ `true` Ø¨Ø±Ú¯Ø´ØªØŒ Ø³Ø±ÛŒØ¹ Ù…ØªÙˆÙ‚Ù Ø¨Ø´Ù‡.

   ```js
   const loop = (data, key, callback) => {
       for (let i = 0; i < data.length; i++) {
           if (data[i].key === key) {
               callback(data[i], i, data)
               return true
           }
           if (data[i].children && loop(data[i].children, key, callback)) {
               return true
           }
       }
       return false
   }
   ```

2. **`parseInt(parentKey)` Ø±ÙˆÛŒ `null`:**
   ÙˆÙ‚ØªÛŒ parent ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ù‡ (Ù…Ø«Ù„Ø§Ù‹ Ù†ÙˆØ¯ ØªÙˆÛŒ Ø±ÛŒØ´Ù‡ Ø¨Ø§Ø´Ù‡)ØŒ `parentKey = null` Ù…ÛŒØ´Ù‡ Ùˆ Ø¨Ø¹Ø¯ `parseInt(null)` Ù…Ù‚Ø¯Ø§Ø± `NaN` Ù…ÛŒØ¯Ù‡.
   Ø¨Ù‡ØªØ±Ù‡ Ù‚Ø¨Ù„ Ø§Ø² ØªØºÛŒÛŒØ± `dragObj.parentId` Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù†ÛŒ:

   ```js
   if (dragObj && parentKey !== null) {
       dragObj.parentId = parseInt(parentKey, 10)
   } else {
       dragObj.parentId = null
   }
   ```

3. **Ø§Ø´ØªØ¨Ø§Ù‡ Ø¯Ø± Ù…Ø±ØªØ¨â€ŒØ³Ø§Ø²ÛŒ `displayOrder`:**
   Ø§ÛŒÙ† Ù‚Ø³Ù…Øª:

   ```js
   const sortedOrder = updatedParentChildren
       .map((item) => item?.displayOrder ?? 0)
       .sort((a, b) => b - a)
   ```

   Ø¯Ø§Ø±Ù‡ Ù‡Ù…Ù‡â€ŒÛŒ displayOrderÙ‡Ø§ Ø±Ùˆ Ø¬Ø¯Ø§Ú¯ÙˆÙ†Ù‡ sort Ù…ÛŒâ€ŒÚ©Ù†Ù‡ (Ù†Ø²ÙˆÙ„ÛŒ)ØŒ Ø¨Ø¹Ø¯Ø´ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø¨Ù‡ ØªØ±ØªÛŒØ¨ index Ø¨Ù‡ Ù†ÙˆØ¯Ù‡Ø§ Ù…ÛŒâ€ŒÚ†Ø³Ø¨ÙˆÙ†Ù‡.
   Ø§ÛŒÙ† Ø¨Ø§Ø¹Ø« Ù…ÛŒØ´Ù‡ ØªØ±ØªÛŒØ¨ Ø¨ØµØ±ÛŒ Ø¯Ø±Ø®Øª **Ù‡Ù…ÛŒØ´Ù‡ Ù†Ø²ÙˆÙ„ÛŒ Ø¨Ø´Ù‡** Ø­ØªÛŒ Ø§Ú¯Ù‡ Ø¬Ø§Ø¨Ù‡â€ŒØ¬Ø§ÛŒÛŒ Ø¬Ø²Ø¦ÛŒ Ø§Ù†Ø¬Ø§Ù… Ø¯Ø§Ø¯Ù‡ Ø¨Ø§Ø´ÛŒ.

   Ø¯Ø±Ø³Øªâ€ŒØªØ± Ø§ÛŒÙ†Ù‡ Ú©Ù‡ `updatedParentChildren` Ø±Ùˆ Ù…Ø³ØªÙ‚ÛŒÙ…Ø§Ù‹ Ø·Ø¨Ù‚ index Ø¨Ú†ÛŒÙ†ÛŒÙ…ØŒ Ù†Ù‡ Ø§ÛŒÙ†Ú©Ù‡ Ù…Ù‚Ø¯Ø§Ø±Ù‡Ø§ Ø±Ùˆ Ø¬Ø¯Ø§ Ú©Ù†ÛŒÙ… Ùˆ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø¨Ú†Ø³Ø¨ÙˆÙ†ÛŒÙ…. ÛŒØ¹Ù†ÛŒ Ø¨Ù‡â€ŒØ¬Ø§ÛŒ `sortedOrder` Ù…ÛŒØ´Ù‡ Ù‡Ù…ÛŒÙ† index Ø±Ùˆ Ø¨Ù‡â€ŒØ¹Ù†ÙˆØ§Ù† order Ø¬Ø¯ÛŒØ¯ Ú¯Ø°Ø§Ø´Øª.

   ```js
   updatedParentChildren.forEach((item, index) => {
       if (item) {
           const oldOrder = prevOrderMap.get(item.key)
           item.displayOrder = index
           if (item.displayOrder !== oldOrder) {
               changedItems.push({...item})
           }
       }
   })
   ```

---

### Ø¬Ù…Ø¹â€ŒØ¨Ù†Ø¯ÛŒ

* Ù…Ø´Ú©Ù„ Ø§ØµÙ„ÛŒ: `children = item.children || []` Ø¨Ø§Ø¹Ø« Ø§ÛŒØ¬Ø§Ø¯ Ù†ÙˆØ¯Ù‡Ø§ÛŒ ØªÚ©Ø±Ø§Ø±ÛŒ Ù…ÛŒØ´Ù‡ â†’ Ø¨Ø§ÛŒØ¯ Ø¯Ø±Ø³Øª Ù…Ø¯ÛŒØ±ÛŒØª Ø¨Ø´Ù‡.
* `loop` Ø¨Ø§ÛŒØ¯ Ù…ØªÙˆÙ‚Ù Ø¨Ø´Ù‡ ØªØ§ recursive Ø¬Ø³ØªØ¬Ùˆ parent Ø±Ùˆ Ú†Ù†Ø¯ Ø¨Ø§Ø± Ù¾ÛŒØ¯Ø§ Ù†Ú©Ù†Ù‡.
* `parentId` Ù†Ø¨Ø§ÛŒØ¯ Ø±ÙˆÛŒ `NaN` Ø³Øª Ø¨Ø´Ù‡.
* `displayOrder` Ø§Ø´ØªØ¨Ø§Ù‡ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…ÛŒØ´Ù‡ (ØªØ±ØªÛŒØ¨ ÙˆØ§Ù‚Ø¹ÛŒ Ø¯Ø±Ø®Øª Ø±Ùˆ Ø¨Ù‡Ù… Ù…ÛŒâ€ŒØ²Ù†Ù‡).

---

Ù…ÛŒâ€ŒØ®ÙˆØ§ÛŒ Ù…Ù† Ù†Ø³Ø®Ù‡â€ŒÛŒ Ø§ØµÙ„Ø§Ø­â€ŒØ´Ø¯Ù‡â€ŒÛŒ `onDrop` Ø±Ùˆ Ø¨Ø±Ø§Øª Ø¨Ø§Ø²Ù†ÙˆÛŒØ³ÛŒ Ú©Ù†Ù… Ú©Ù‡ Ø§ÛŒÙ† Ù…Ø´Ú©Ù„Ø§Øª Ø­Ù„ Ø¨Ø´Ù†ØŸ


///////////////////////////////////////////////////////////////////////////////////


import PropTypes from 'prop-types'
import DynamicTree from './DynamicTree'
import { useCallback } from 'react'

const DraggableTree = ({
    gData,
    setGData,
    loader,
    data,
    onItemChange,
    loadedKeys,
    onLoadKeys,
    ...rest
}) => {
    const onDrop = useCallback(
        (info) => {
            const dropKey = info.node.key
            const dragKey = info.dragNode.key
            const dropPos = info.node.pos.split('-')
            const dropPosition =
                info.dropPosition - Number(dropPos[dropPos.length - 1])

            const loop = (data, key, callback) => {
                for (let i = 0; i < data.length; i++) {
                    if (data[i].key === key) {
                        return callback(data[i], i, data)
                    }
                    if (data[i].children) {
                        loop(data[i].children, key, callback)
                    }
                }
            }

            const dataCopy = [...gData]
            let dragObj

            loop(dataCopy, dragKey, (item, index, arr) => {
                arr.splice(index, 1)
                dragObj = item
            })

            let updatedParentChildren = []
            let parentKey = null

            if (!info.dropToGap) {
                loop(dataCopy, dropKey, (item) => {
                    item.children = item.children || []
                    item.children.unshift(dragObj)
                    updatedParentChildren = item.children
                    parentKey = item.key
                })
            } else {
                let ar = []
                let i
                loop(dataCopy, dropKey, (_item, index, arr) => {
                    ar = arr
                    i = index
                })
                if (dropPosition === -1) {
                    ar.splice(i, 0, dragObj)
                } else {
                    ar.splice(i + 1, 0, dragObj)
                }

                const findParentKey = (data, childKey) => {
                    let result = null
                    const search = (nodes, parent = null) => {
                        for (const node of nodes) {
                            if (node.key === childKey) {
                                result = parent
                                return
                            }
                            if (node.children) {
                                search(node.children, node.key)
                            }
                        }
                    }
                    search(data)
                    return result
                }

                parentKey = findParentKey(dataCopy, dragObj.key)

                const getChildren = (data, key) => {
                    let children = []
                    loop(data, key, (item) => {
                        children = item.children || []
                    })
                    return children
                }

                updatedParentChildren = parentKey
                    ? getChildren(dataCopy, parentKey)
                    : dataCopy
            }

            // Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² NaN
            if (dragObj) {
                dragObj.parentId =
                    parentKey !== null ? parseInt(parentKey, 10) : null
            }

            const prevOrderMap = new Map()
            updatedParentChildren.forEach((item) => {
                if (item) {
                    prevOrderMap.set(item.key, item.displayOrder ?? 0)
                }
            })

            const changedItems = []
            updatedParentChildren.forEach((item, index) => {
                if (item) {
                    const oldOrder = prevOrderMap.get(item.key)
                    item.displayOrder = index
                    if (item.displayOrder !== oldOrder) {
                        changedItems.push({
                            ...item,
                        })
                    }
                }
            })

            if (dragObj) {
                changedItems.push({
                    ...dragObj,
                })
            }

            setGData(dataCopy)
            onItemChange?.(changedItems)
        },
        [gData, onItemChange, setGData]
    )

    return (
        <DynamicTree
            className="draggable-tree"
            loader={loader}
            data={data}
            draggable
            blockNode
            onDrop={onDrop}
            treeData={gData}
            onLoad={setGData}
            loadedKeys={loadedKeys}
            onLoadKeys={onLoadKeys}
            {...rest}
        />
    )
}

DraggableTree.propTypes = {
    loader: PropTypes.func,
    gData: PropTypes.array,
    data: PropTypes.array,
    setGData: PropTypes.func,
    onItemChange: PropTypes.func,
    loadedKeys: PropTypes.array,
    onLoadKeys: PropTypes.func,
}

export default DraggableTree

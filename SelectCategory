خیلی عالی 👌
پس من هر دو فایل رو بر اساس همون نسخه جدیدی که فرستادی بازنویسی می‌کنم، با این تفاوت‌ها:

* **CategoryCascader.jsx**

  * تمیز و ساده نگه داشته میشه (مثل کدی که خودت دادی).
  * `loading` برای lazy load اضافه می‌کنم (UX بهتر).
  * `error handling` هم اضافه میشه.
  * flat شدن بعد سرچ حفظ میشه (همون‌طور که گفتی مشکلی نداره).

* **SelectCategory.jsx**

  * فقط wrapper هست، پس ساده و خوانا نگه می‌دارمش.
  * قابلیت اضافه‌کردن دسته جدید (Modal + Plus button) حفظ میشه.
  * امکان پاس دادن `customOptions` هم لحاظ میشه.

---

## 📂 `CategoryCascader.jsx`

```jsx
import { Cascader } from 'antd'
import { useCallback, useEffect, useMemo, useState } from 'react'
import PropTypes from 'prop-types'
import api from '../axios-proxy'
import debounce from 'lodash.debounce'

// Helper: ساخت نود استاندارد
function normalizeItem(item) {
  return {
    key: item.id,
    value: item.id,
    label: item.title,
    isLeaf: false,
    ...item,
  }
}

// Helper: ساخت درخت از داده‌های flat
function buildTree(data) {
  const map = new Map()
  const tree = []

  data.forEach((item) => {
    map.set(item.id, { ...normalizeItem(item), children: [] })
  })

  data.forEach((item) => {
    if (item.parentId && map.has(item.parentId)) {
      map.get(item.parentId).children.push(map.get(item.id))
    } else if (!item.parentId) {
      tree.push(map.get(item.id))
    }
  })

  return tree
}

const CategoryCascader = ({ value, onChange, endpoint, customOptions = [], ...rest }) => {
  const [options, setOptions] = useState([])
  const [loadingKeys, setLoadingKeys] = useState([])

  // --- API Caller ---
  const fetchData = useCallback(
    async ({ id, parentId, searchAll, search }) => {
      try {
        const url =
          typeof endpoint === 'function'
            ? endpoint({
                id,
                parentId,
                query: search ? `&titleContains=${search}` : '',
                searchAll,
              })
            : endpoint

        const res = await api.get(url)
        const sortedData = res.data.items?.sort(
          (a, b) => a.displayOrder - b.displayOrder
        ) ?? []

        return sortedData.map(normalizeItem)
      } catch (err) {
        console.error('❌ fetchData error:', err)
        return []
      }
    },
    [endpoint]
  )

  // --- Search handler ---
  const handleSearch = useMemo(
    () =>
      debounce((q) => {
        fetchData({ searchAll: true, search: q }).then((res) => {
          setOptions(res) // flat list برای جستجو
        })
      }, 500),
    [fetchData]
  )

  // --- مقدار اولیه: لود ریشه‌ها ---
  useEffect(() => {
    fetchData({ parentId: null }).then((data) => {
      setOptions(buildTree([...customOptions, ...data]))
    })
  }, [fetchData, customOptions])

  // --- بارگذاری Lazy children ---
  const loadData = (selectedOptions) => {
    const target = selectedOptions[selectedOptions.length - 1]
    setLoadingKeys((prev) => [...prev, target.key])

    fetchData({ parentId: target.key })
      .then((children) => {
        setOptions((prev) =>
          children?.length ? buildTree([...prev, ...children]) : prev
        )
      })
      .finally(() => {
        setLoadingKeys((prev) => prev.filter((k) => k !== target.key))
      })
  }

  return (
    <Cascader
      value={value}
      options={options}
      loadData={loadData}
      onChange={onChange}
      onSearch={handleSearch}
      changeOnSelect
      autoClearSearchValue
      showSearch
      loading={loadingKeys.length > 0}
      {...rest}
    />
  )
}

CategoryCascader.propTypes = {
  value: PropTypes.array,
  onChange: PropTypes.func,
  endpoint: PropTypes.oneOfType([PropTypes.string, PropTypes.func]).isRequired,
  customOptions: PropTypes.array,
}

export default CategoryCascader
```

---

## 📂 `SelectCategory.jsx`

```jsx
import { Button, Space } from 'antd'
import PropTypes from 'prop-types'
import { useCallback, useState } from 'react'
import { TbPlus } from 'react-icons/tb'
import CategoryModal from './CategoryModal'
import CategoryCascader from './CategoryCascader'

const SelectCategory = ({
  id,
  value,
  onChange,
  mode = null,
  placeholder = 'انتخاب دسته‌بندی',
  ownerResourceId,
  customOptions = [],
}) => {
  const [hasModal, setHasModal] = useState(false)

  const endpoint = useCallback(
    ({ parentId, id, query, searchAll }) => {
      const parentQuery =
        searchAll || id
          ? ''
          : parentId
            ? `&parentIdEqualsTo=${parentId}`
            : '&parentIdIsNull=true'

      return `/api/categories?ownerResourceIdEqualsTo=${ownerResourceId}${
        id ? `&idEqualsTo=${id}` : ''
      }${parentQuery}${query}`
    },
    [ownerResourceId]
  )

  return (
    <div id={id} style={{ width: '100%' }}>
      <Space.Compact block>
        <CategoryCascader
          value={value}
          onChange={onChange}
          endpoint={endpoint}
          placeholder={placeholder}
          customOptions={customOptions}
          multiple={mode === 'multiple'}
        />
        <Button icon={<TbPlus />} onClick={() => setHasModal(true)} />
      </Space.Compact>

      <CategoryModal
        open={hasModal}
        ownerResourceId={ownerResourceId}
        onClose={() => setHasModal(false)}
      />
    </div>
  )
}

SelectCategory.propTypes = {
  id: PropTypes.string,
  value: PropTypes.any,
  mode: PropTypes.string,
  onChange: PropTypes.func,
  placeholder: PropTypes.string,
  customOptions: PropTypes.array,
  ownerResourceId: PropTypes.number.isRequired,
}

export default SelectCategory
```

---

## ✨ تغییرات کلیدی

1. **CategoryCascader**

   * اضافه شدن **loading indicator** برای UX بهتر.
   * اضافه شدن **error handling** در `fetchData`.
   * کد تمیزتر و ساده‌تر.

2. **SelectCategory**

   * ساده‌سازی و خوانایی بهتر.
   * `multiple` به صورت مستقیم از `mode` گرفته میشه.
   * `placeholder` پیش‌فرض گذاشته شده.

---

می‌خوای من یه **دموی کوچک** هم درست کنم (مثلاً یه صفحه تست) که این دو کامپوننت رو کنار هم نشون بده تا راحت‌تر بتونی تست کنی؟
